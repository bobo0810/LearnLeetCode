# 解题模板

## 数组

### 1. 前缀和

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        # 非单调，要前缀和  
        
        count=0 #记录总数
        cur_sum=0 # 当前前缀和为0
        prefix_count={0:1} # 哈希表，前缀和为0 出现1次

        for num in nums:
            # 更新当前前缀和
            cur_sum+=num
            # 如果满足条件的前缀和 记录总数
            count+=prefix_count.get(cur_sum-k,0)
            # 更新哈希表
            prefix_count[cur_sum]=prefix_count.get(cur_sum,0)+1
        return count
```

### 2. 滑动窗口

四步

（1）队头移出过期索引 

（2）队尾移出小于当前值的索引 

（3）队尾添加当前索引 

（4）满足条件时统计信息

#### 静态窗口

```python
# 遍历字符
for right in range(len(strs)):
    # 持续右进
    # 当前窗口不满足条件时左出
    # 当前窗口满足需求时统计信息
```

#### 动态窗口

```python
left=0
# 无重复字符的最长子串 用set() 
# 异位词 用Counter字典
windows=set()  
#  外层循环移动右指针，内层循环移动左指针
for right in range(len(strs)):
    # 判断当前元素strs[right]
    # 当前区间[left,right]不满足条件时，移动左指针直到满足条件
    while left<=right and check(xxx):
        # 左侧窗口移出元素，左指针右移
        windows.remove(strs[left])
        left+=1
    
    # 当前区间[left,right]满足条件时，加入窗口并统计信息
    windows.add(strs[right]) 
```

### 3. 查找算法

#### 二分查找

时间复杂度O(logn)

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1 # 循环不变量 双闭区间
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1  
        else:
            right = mid - 1 
    return -1
```

### 4. 排序算法

#### 快速排序QuickSort

时间复杂度O(nlogn)

```python
def quicksort(arr, low, high):
    """
    :param arr: 待排序的数组
    :param low: 排序的起始索引
    :param high: 排序的结束索引
    """
    if low < high:
        # 获取基准元素的索引
        pivot_index = partition(arr, low, high)

        # 递归排序基准左侧和右侧部分
        quicksort(arr, low, pivot_index - 1)  # 排序左侧
        quicksort(arr, pivot_index + 1, high)  # 排序右侧

def partition(arr, low, high):
    """
    分区函数，选择一个基准元素并将数组分为两部分

    :param arr: 待排序的数组
    :param low: 排序的起始索引
    :param high: 排序的结束索引
    :return: 基准元素的最终位置
    
    总结
    选择基准: 选择数组的最后一个元素作为基准。
    分区过程: 遍历数组，将小于基准的元素移动到左侧。
    放置基准: 将基准元素放到它的正确位置。
    返回值: 返回基准元素的新索引，以便快速排序的递归调用使用。
    """
    pivot = arr[high]  # 选择最后一个元素作为基准
    i = low - 1  # 小于基准的元素的最后一个索引

    # 遍历数组并进行分区
    for j in range(low, high):
        if arr[j] < pivot:
            i = i + 1  # 增加小于基准的元素的索引
            arr[i], arr[j] = arr[j], arr[i]  # 交换元素

    # 将基准元素放到正确的位置
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1  # 返回基准元素的位置
```

### 5. 单调栈

```python
def stack(nums):
    n = len(nums)
    result = [0] * n  # 根据题目初始化结果
    stack = []  # 栈中存储索引
    
    for i in range(n):  # 遍历数组
        # 根据条件调整栈顶元素
        while stack and <当前元素与栈顶索引元素满足条件>:
            idx = stack.pop()  # 弹出栈顶
            result[idx] = <根据题目更新结果>
        stack.append(i)  # 当前元素入栈
    
    return result
```

### 6. 矩阵顺时针遍历

```python
# 定义四个边界 
def spiralOrder(matrix):
    if not matrix:
        return []

    # 初始化边界   双闭区间
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1
    
    result = []
    
    while top <= bottom and left <= right:
        # 从左到右遍历该行
        for i in range(left, right + 1): 
            result.append(matrix[top][i])
        top += 1  # 遍历完移到下一行
        
        # 从上到下
        for i in range(top, bottom + 1):
            result.append(matrix[i][right])
        right -= 1
        
        # 从右到左遍历行  先判断行是否越界
        if top <= bottom: 
            for i in range(right, left - 1, -1):
                result.append(matrix[bottom][i])
            bottom -= 1
        
        # 从下到上遍历列   先判断列是否越界
        if left <= right:
            for i in range(bottom, top - 1, -1):
                result.append(matrix[i][left])
            left += 1
    
    return result
```

### 

## 链表

### 1. 插入元素

#### 头插



#### 尾插

1. 保存下一个节点
2. 尾插      旧指None    新指旧
3. 新表更新尾节点
4. 旧表更新头结点

### 2. 翻转链表
思路：保存->翻转->前后移
```python
def reverse_linked_list(head):
    """
    :param head: 链表的头节点
    :return: 翻转后的链表头节点
    """
    prev = None  # 上一个节点，初始化为 None
    current = head  # 当前节点，初始化为链表的头节点

    # 遍历链表，直到当前节点为空   
    while current:
        next_node = current.next  # 保存下一个节点
        current.next = prev  # 将当前节点的next指针指向上一个节点（翻转指针）
        prev = current  # 移动 prev 到当前节点
        current = next_node  # 移动到下一个节点

    return prev  # 返回新的头节点（翻转后的链表头）
```

### 3. 合并两个有序链表

时间复杂度为 O(m + n)

```python
def merge_two_lists(l1, l2):
    # 创建一个虚拟头节点，方便处理合并操作
    dummy = ListNode(0)
    current = dummy  # 用于遍历和构建合并链表的指针

    # 遍历两个链表，直到其中一个链表为空
    while l1 and l2:
        # 比较两个链表的当前节点的值
        if l1.val < l2.val:
            # 如果 l1 的值更小，将 l1 的节点添加到合并链表中
            current.next = l1
            l1 = l1.next  # 移动 l1 指针到下一个节点
        else:
            # 如果 l2 的值更小或相等，将 l2 的节点添加到合并链表中
            current.next = l2
            l2 = l2.next  # 移动 l2 指针到下一个节点
        
        # 移动 current 指针到合并链表的下一个位置
        current = current.next

    # 处理剩余的节点
    # 只需将 l1 或 l2 中剩余的节点连到合并链表的末尾
    if l1:
        current.next = l1
    if l2:
        current.next = l2

    # 返回合并后的链表，去掉虚拟头节点
    return dummy.next
```









## 二叉树

### 1. 深度优先遍历DFS

#### 递归三步骤

1. 确定递归函数的参数和返回值
2. 确定终止条件
3. 确定单层递归的逻辑

#### 迭代法

[统一写法](https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%9D%E8%B7%AF)

```
# 用栈实现，所以 倒序。
前序：中左右    迭代是右左中
中序：左中右     迭代是右左中   
后序：左右中     迭代是中右左     
```

### 2. 广度优先搜索（BFS）

#### [层序遍历](https://www.programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html#_102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86)

```python
# 利用长度法
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        queue = collections.deque([root]) # deque双端队列  装入根节点
        result = []
        while queue: # 1. 遍历每一层
            # 2. 遍历当前层的节点   长度划分出当前层的元素个数，for pop遍历并清空当前层元素
            level = [] 
            nums=len(queue) # queue动态变化，必须先统计长度
            for _ in range(nums): 
                cur = queue.popleft() 
                level.append(cur.val)
                # 3. 装入左右子树
                if cur.left: 
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            result.append(level) # 4. 保存当前层结果
        return result
```

```python
#递归法
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: #边界
            return []
        levels = []
        def traverse(node, level): # 1. 确定参数和返回值   level指第几层 0~n-1
            if not node: # 2. 终止条件
                return
             # 3. 单层递归逻辑
            if len(levels) == level: #level从0开始   len从1开始。 如果不同，需要初始化新的一层
                levels.append([])
            levels[level].append(node.val)
            traverse(node.left, level + 1)
            traverse(node.right, level + 1)
        traverse(root, 0)
        return levels
```



## 图论

### 1. 深度优先遍历

岛屿数量

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        res=0 # 岛屿数量初始化为0
       
        # 遍历grid
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                # 判断当前元素 是否为1，即为岛屿
                if grid[i][j]=="1":
                    # 每发现一个岛屿，岛屿数+1
                    res+=1
                    # 用深度优先遍历DFS将岛屿淹掉
                    self.dfs(grid,i,j)
        return res
    def dfs(self,grid,i,j):
        # 递归终止条件  上下左右四边
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]):
            # 超出索引边界  什么都不操作
            return 
        if grid[i][j]=="0":
            # 已经是海水  什么都不操作
            return 

        # 将（i，j）变为海水
        grid[i][j]="0"
        # 同时递归淹没上下左右陆地
        self.dfs(grid,i-1,j)
        self.dfs(grid,i+1,j)
        self.dfs(grid,i,j-1)
        self.dfs(grid,i,j+1)
```

### 2. 广度优先遍历

腐烂橘子

```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        from collections import deque
        # 1. 统计腐烂橘子坐标，统计新鲜橘子数量
        # 2. 腐烂橘子同时传播一次，减少新鲜橘子数量
        # 3. 全部传播完后判断是否还有新鲜橘子
        deq = deque()  # 保存腐烂橘子
        fresh_nums = 0  # 新鲜橘子的数量

        # 遍历整个网格，初始化腐烂橘子的坐标并统计新鲜橘子的数量
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    fresh_nums += 1  # 统计新鲜橘子
                elif grid[i][j] == 2:
                    deq.append((i, j))  # 添加腐烂橘子的位置
        
        # 如果没有新鲜橘子，直接返回0
        if fresh_nums == 0:
            return 0
        
        # 开始腐烂
        time = 0  # 耗时
        direct = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 上下左右四个方向
        while deq:
            # 当前这波腐烂的橘子数目
            for _ in range(len(deq)):
                x, y = deq.popleft()  # 获取当前腐烂橘子的位置
                # 尝试上下左右传播腐烂
                for dx, dy in direct:
                    nx, ny = x + dx, y + dy
                    # 判断新位置是否有效且是新鲜橘子
                    if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1:
                        grid[nx][ny] = 2  # 将新鲜橘子腐烂
                        fresh_nums -= 1  # 新鲜橘子数量减少
                        deq.append((nx, ny))  # 将新腐烂的橘子加入队列
            time += 1  # 每次while结束，时间增加

        # 最后一次传播是多余的，所以-1

        # 如果还有新鲜橘子，返回-1，否则返回总时间
        return time - 1 if fresh_nums == 0 else -1
```

## 回溯

三步骤

1. 回溯函数模板 参数及返回值

   参数：path存放结果，result存放结果集，startIndex下一层for循环搜索的起始位置

2. 回溯函数终止条件

3. 遍历过程 （思考N叉树，横向遍历什么   纵向遍历什么）

```python
def backtracking(result,path,xxx): 
    if 终止条件:
        result.append(path[:])  # 存放结果 必须[:]返回新列表
        return   #返回
    for i in range(len(xxx)): # 数组左闭右开[ ), 结尾剪枝
        处理当前值
        backtrack(path,result,xxx)  # 如果有startIndex， i表示可重复  i+1不能重复取
        撤销当前值
# 定义全局变量
result,path=[],[]
backtracking(result,path,xxx)
return result 
```

## 动态规划

五步骤：DP下标定义  公式  初始化  顺序  举例

1. dp下标定义
2. 递推公式
3. 初始化
4. 遍历顺序
5. 举例推导dp数组

- 求最值      外层for背包  内层for物品
- 求排列数（强调顺序）   外层for背包，内层for物品。
- 求组合数（凑零钱）   外层for物品，内层for背包。

