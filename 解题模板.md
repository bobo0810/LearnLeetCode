[TOC]

# 解题模板



## 1. 矩阵

### 花式遍历 

```python
def spiralOrder(matrix):
    if not matrix:
        return []

    # 初始化边界
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1
    
    result = []
    
    while top <= bottom and left <= right:
        # 从左到右遍历行，行不变
        for i in range(left, right + 1):
            result.append(matrix[top][i])
        top += 1  # 遍历完移到下一行
        
        # 从上到下
        for i in range(top, bottom + 1):
            result.append(matrix[i][right])
        right -= 1
        
        # 从右到左遍历行  先判断行是否越界
        if top <= bottom: 
            for i in range(right, left - 1, -1):
                result.append(matrix[bottom][i])
            bottom -= 1
        
        # 从下到上遍历列   先判断列是否越界
        if left <= right:
            for i in range(bottom, top - 1, -1):
                result.append(matrix[i][left])
            left += 1
    
    return result
```

## 2. 滑动窗口

### 静态窗口

```python
# 遍历字符
for right in range(len(strs)):
    # 持续右进
    # 当前窗口不满足条件时左出
    # 当前窗口满足需求时统计信息
```

### 动态窗口

```python
left=0
# 无重复字符的最长子串 用set() 
# 异位词 用Counter字典
windows=set()  
#  外层循环移动右指针，内层循环移动左指针
for right in range(len(strs)):
    # 判断当前元素strs[right]
    # 当前区间[left,right]不满足条件时，移动左指针直到满足条件
    while left<=right and check(xxx):
        # 左侧窗口移出元素，左指针右移
        windows.remove(strs[left])
        left+=1
    
    # 当前区间[left,right]满足条件时，加入窗口并统计信息
    windows.add(strs[right]) 
```

## 3. 数组

### 前缀和

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        # 非单调，不能滑动窗口  要前缀和  
        
        count=0 #记录总数
        cur_sum=0 # 当前前缀和为0
        prefix_count={0:1} # 哈希表，前缀和为0 出现1次

        for num in nums:
            # 更新当前前缀和
            cur_sum+=num
            # 如果满足条件的前缀和 记录总数
            count+=prefix_count.get(cur_sum-k,0)
            # 更新哈希表
            prefix_count[cur_sum]=prefix_count.get(cur_sum,0)+1
        return count
```

## 4. 二叉树

### 前中后序遍历

```python

def traverse(root):
    if root is None:
        return
    # 前序位置
    traverse(root.left)
    # 中序位置
    traverse(root.right)
    # 后序位置
```

[link](https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86-dfs)

### 深度优先遍历DFS

​	1.	**判断递归终止条件**（如节点为空）。

​	2.	**对子树进行递归调用**。

​	3.	**处理当前节点逻辑**（如交换左右子树）。

​	4.	**返回当前节点的状态**（作为父节点的子树）。

```python

def recursive_function(node):
    """
    通用递归模板
    :param node: 当前处理的节点
    :return: 当前节点的结果（根据问题定义）
    """
    # 1. 基本情况（递归终止条件）
    if node is None:
        return 0  # 或者其他适合问题的返回值

    # 2. 递归计算子问题
    left_result = recursive_function(node.left)  # 递归计算左子树
    right_result = recursive_function(node.right)  # 递归计算右子树

    # 3. 合并子问题的结果
    #- 求最大值：return max(left_result, right_result) + 1
    #- 求最小值：return min(left_result, right_result) + 1
    #- 求累加和：return left_result + right_result + 当前节点值
    result = combine_results(left_result, right_result)

    # 4. 返回结果
    return result

```

### 广度优先搜索（BFS）

```python
from collections import deque

from collections import deque

def bfs_template(root):
    """
    BFS 模板，用于按层遍历二叉树
    :param root: 二叉树的根节点
    :return: 按问题定义返回结果
    """
    if not root:
        return 0  # 空树的特殊情况处理
          result = 0  # 初始化结果（具体根据问题定义）

    while queue:
        # 处理当前层的所有节点
        level_size = len(queue)  # 当前层的节点数
        for _ in range(level_size):
            node = queue.popleft()  # 取出当前节点

            # 在这里处理当前节点（根据问题需求处理）
            # 例如累加节点值、统计节点数等
            # result += node.val（假如需要累加节点值）

            # 将子节点加入队列
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        # 在这里处理层级相关操作（如层数加1）
        # result += 1（假如问题是求深度）
        result += 1

    return result

   
	1.	队列初始化
将根节点作为队列的初始元素。
	2.	层级控制
使用 level_size 控制每次遍历的层级节点数量，确保所有节点按层遍历。
```



## 5. 图论

### 岛屿数量- 深度优先遍历

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        res=0 # 岛屿数量初始化为0
       
        # 遍历grid
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                # 判断当前元素 是否为1，即为岛屿
                if grid[i][j]=="1":
                    # 每发现一个岛屿，岛屿数+1
                    res+=1
                    # 用深度优先遍历DFS将岛屿淹掉
                    self.dfs(grid,i,j)
        return res
    def dfs(self,grid,i,j):
        # 递归终止条件  上下左右四边
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]):
            # 超出索引边界  什么都不操作
            return 
        if grid[i][j]=="0":
            # 已经是海水  什么都不操作
            return 

        # 将（i，j）变为海水
        grid[i][j]="0"
        # 同时递归淹没上下左右陆地
        self.dfs(grid,i-1,j)
        self.dfs(grid,i+1,j)
        self.dfs(grid,i,j-1)
        self.dfs(grid,i,j+1)
```

### 腐烂橘子- 广度优先遍历

```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        from collections import deque
        # 1. 统计腐烂橘子坐标，统计新鲜橘子数量
        # 2. 腐烂橘子同时传播一次，减少新鲜橘子数量
        # 3. 全部传播完后判断是否还有新鲜橘子
        deq = deque()  # 保存腐烂橘子
        fresh_nums = 0  # 新鲜橘子的数量

        # 遍历整个网格，初始化腐烂橘子的坐标并统计新鲜橘子的数量
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    fresh_nums += 1  # 统计新鲜橘子
                elif grid[i][j] == 2:
                    deq.append((i, j))  # 添加腐烂橘子的位置
        
        # 如果没有新鲜橘子，直接返回0
        if fresh_nums == 0:
            return 0
        
        # 开始腐烂
        time = 0  # 耗时
        direct = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 上下左右四个方向
        while deq:
            # 当前这波腐烂的橘子数目
            for _ in range(len(deq)):
                x, y = deq.popleft()  # 获取当前腐烂橘子的位置
                # 尝试上下左右传播腐烂
                for dx, dy in direct:
                    nx, ny = x + dx, y + dy
                    # 判断新位置是否有效且是新鲜橘子
                    if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1:
                        grid[nx][ny] = 2  # 将新鲜橘子腐烂
                        fresh_nums -= 1  # 新鲜橘子数量减少
                        deq.append((nx, ny))  # 将新腐烂的橘子加入队列
            time += 1  # 每次while结束，时间增加

        # 最后一次传播是多余的，所以-1

        # 如果还有新鲜橘子，返回-1，否则返回总时间
        return time - 1 if fresh_nums == 0 else -1
```

## 6.  查找算法

### 二分查找

时间复杂度O(logn)

```python
def binary_search_insert_position(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

## 
