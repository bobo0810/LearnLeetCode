# Hot100解题思路



## 数组

### 1. 自身以外数组的乘积

思路：前缀乘   后缀乘

### 2. 轮转数组

思路：  

1. k%数组长度后，得到真实翻转次数
2. 先整体翻转、再左区间单独翻转、右区间单独翻转

### 3. 划分字母区间：字符串划分为尽可能多的片段，同一字母只能出现在一个片段中。

思路：

1. 第一次遍历，统计每个字符的最后出现位置
2. 第二次遍历，每次更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点

### 4. 合并区间:  合并所有重叠的区间，并返回不重叠的区间数组

思路：

1. 排序：按照子数组的第一个元素排序 
2. 合并：按照第二个元素合并。 分3种情况  不重叠、重叠、包含

   ```python
   pre_left,pre_right = result[-1]  # 结果里的最后一个区间
   cur_left,cur_right = intervals[i] # 当前区间
   ```

### 5. 最大子数组的和

思路：  

1. 更新当前的前缀和 
   - 如果之前>0，则有益  更新为prefix+当前值。
   - 如果之前<0，则有害  重置为当前值
2. 更新当前的最大值  

### 6. 无重复字符的最长子串

思路：哈希  Set集合，记录窗口内每个字符是否出现

### 7. 三数之和

思路：排序＋双指针

### 8. 和为 K 的子数组：整数数组 nums 和一个整数 k ，统计和为 k 的子数组的个数 

思路： 用前缀和+哈希表

哈希表{前缀和：出现次数}，如果 （当前前缀和−k 的区间和j ）在哈希表，则总次数 累加上map[j]的值

### 9. 翻转字符串里的单词 

 思路： 全部翻转，再翻转每个单词

### 10. 移动零：所有 0 移动到数组的末尾

思路：双指针，快指针持续走到 满足条件的元素，与慢指针交换。然后同时右走

### 11. 最长连续序列 ：未排序的整数数组 nums ，找出数字连续的最长序列

（不要求序列元素在原数组中连续）      

思路：每个数 判断是否为连续序列的开头。

用Set判断是否包含当前元素-1。 跳过非开头

### 12. 缺失的第一个正整数

思路： 理想情况下 下标+1=正整数

1. 交换：遍历到下标i,  如果对应值在1~n范围内，且与下标不匹配，则持续交换。   

   - 交换的终止条件是 即将交换的位置已经有匹配元素。

   -  必须理清 当前下标、当前值、交换下标、交换值。 下标嵌套，交换前下标不得嵌套

2. 遍历：第一个与下标不匹配的元素即为缺失正整数

### 13. 图像顺时针旋转90°  

思路：矩阵对角线交换+每行翻转

## 二分查找

### 1. 搜索二维矩阵

思路： 坐标映射到一维，进行二分查找

## 排序

### 1. 数据中出现频率前 k 高的元素

思路：堆排序


## 链表

### 1. 链表相交，求交点

![2024-12-24](./assets/2024-12-24.png)

思路：

1. 链表A走A+B路程，链表B走B+A路径。持续比较 两个节点。
2. 终止条件是两个节点相等，中途相等则相交，都走完则不想交。

### 2. 环形链表判断是否有环？环入口？

![2024-12-24-2](./assets/2024-12-24-2.png)

1. 快慢指针相遇，则有环。
2. 相遇时，慢节点回到头节点，快慢指针同步走，再次相遇是入口

### 3. 回文链表

思路：快慢指针找中点，翻转后半 再同时遍历两个链表

### 4. 翻转链表

思路：3个指针  新链表表头new_node、旧链表当前节点cur_node、旧链表下一个节点next_node

### 5. 链表模拟两数之和 

思路：少的链表高位为0、考虑进位

### 6. 删除倒数第N个节点

思路：虚拟头结点+快慢指针



## 栈

### 1. 获取最小元素的栈

思路：额外维护一个最小栈，保持长度一致

### 2. 字符串解码 

例如"3[a]2[bc]&quot;解码为&quot;aaabcbc"

思路：

1. 遇到 [   栈存入已解码的字符串 + 即将重复的数字
2. 遇到]   栈弹出 已解码字符串和即将重复数字，构建新字符串

### 3. 每日温度

xxx

## 二叉树

### 1. 验证二叉搜索树

思路：<span style="color:red;">中序遍历</span>成数组，再判断是否递增

### 2. 从前序和中序构建二叉树

思路： 递归不断拆分左右区间，构建左右子树

1. 前序第一个节点 将中序拆成左右区间
2. 用中序左区间长度 将前序业拆成左右区间
3. 得到前序 中序的左右区间后递归即可

## 图论

### 1. 岛屿数量

思路：深度优先遍历DFS，每遍历到一个岛屿，就递归淹掉周围的陆地

### 2. 腐烂的橘子

思路：广度优先遍历BFS   因为所有橘子同时腐烂



## 回溯

### 1. 电话号码的字母组合

思路：横向遍历 单个数字对应的字母集合，纵向遍历 didigits的N个数字

## 贪心

### 1. 买卖股票的最佳时机，只能买卖一次

思路：每个元素找右侧的最大值，从右向左构建最大栈

### 2. 跳跃游戏：数组中的每个元素代表你在该位置可以跳跃的最大长度。判断是否能跳到最后一个下标。

思路：关注最大跳跃范围是否到达下标n-1位置

1. 每移动一个单位，先判断是否能到达   每走一步都更新最远范围
2. 如果能到达，更新最远覆盖范围，同时判断是否>=下标n-1位置

### 3. 跳跃游戏II：返回最小跳跃次数

思路：最少步数走最远范围    

1. cur_range    当前能走的最远下标
2. next_range   在cur_range范围内，每走一步都更新最远范围
3. step  记录最小步数。一切以i为准,判断是否走到头、再是否到达目的地。最后的步数就是最少步数

## 动态规划

### 常规问题

#### 1. 杨辉三角

思路：填充二维dp数组的左下三角，第一列和对角线全为1，剩余元素=左+上

#### 2. 打家劫舍，不能偷相邻房屋

思路：

1. dp[i]定义   房间序号从前i个房间内偷的最高金额
2. 如果偷房间i，则最多考虑从0~i-2房间偷dp[i-2]+ nums[i]

如果不偷房间i，则最多考虑0~i-1偷dp[i-1]

dp[i]= max(dp[i-2]+nums[i], dp[i-1])

#### 3. 乘积最大子数组，元素有正有负

思路：因为元素存在负数，导致最大值 最小值相互转换，所以同时维护两个dp_max   dp_min

1. dp定义   第 i 个元素结尾的乘积最大子数组的乘积

2. 公式   

   ```python
   dp_max[i] = max( nums[i], dp_max[i-1]*num[i], dp_min[i-1]*num[i]) 
   dp_min[i] = min(nums[i], dp_max[i-1]*num[i], dp_min[i-1]*num[i] )
   ```

   

### 背包问题

#### 1. 完全平方数：和为 n 的完全平方数的最少数量 。例如13 = 2²+3²

思路：物品无限取，装满背包，即完全背包问题

背包容量是n，物品是i  取值范围是0~√n

1. dp[i]定义  和为i的最少数量
2. 公式  dp[i]=  min(dp[i-j²] ,dp[i])    j取值范围0~√i
3. 初始化   因为求最小值，故dp初始化为无穷大

#### 2. 分割等和子集：数组分割成两个子集，使得两个子集的元素和相等 

思路： 找到集合里能够出现 sum / 2 的子集总和。即 01背包问题

1. dp定义  容量为j的背包，所背的物品价值最大可以为dp[j]
2. 公式   dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

### 子序列问题

#### 1. 单词拆分

思路：

1. dp[i]定义：字符串长度为i    无法拼出为False    拼出为True
2. 递推公式：如果dp[j]True  且s[j:i]在单词列表里，则dp[i]为True      ( j<i)

#### 2. 最长递增子序列

定义 dp[i] 表示0~i-1区间内以nums[i-1]结尾的最长子序列长度 

#### 3. No72.最短编辑距离

思路：

1. dp定义   dp[i][j] word1前i个元素、word2前j个元素的最少次数
2. 递推公式  
   - 当前元素相同，则不操作  `dp[i][j]=dp[i-1][j-1]`
   - 不同，则 增加、删除、修改,选最少次数




## 技巧

### 1. 只出现一次的数字，即除了某个元素只出现一次以外，其余每个元素均出现两次

思路：异或运算，相同为0，不同为1

```python
result = 0
for num in nums:
    result ^= num
return result
```

