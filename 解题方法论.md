# 解题方法论



## 字符串

### 1. 字符串解码

&quot;3[a]2[bc]&quot;解码为&quot;aaabcbc"

```python
class Solution:
    def decodeString(self, s: str) -> str:
        stack=[] 
        cur_str="" # 存储当前字符串
        cur_num=0 # 存储当前重复数字

        for char in s:
            # 数字  可能出现连续数字
            if char.isdigit():
                cur_num=cur_num*10+int(char)
            # [
            elif char=="[":
                # 入栈  保存之前的字符串 + 将要重复的数字
                stack.append([cur_str,cur_num])
                # 恢复
                cur_str=""
                cur_num=0
            # ]
            elif char =="]":
                # 出栈
                pre_str,nums=stack.pop()
                cur_str=pre_str+ cur_str*nums # 当前字符串是要重复的目标
            # 字母
            else:
                cur_str+=char
        return cur_str
```



## 数组

### 1. 前缀和    区间和

### 2. 滑动窗口

#### 滑动窗口三步骤

- 什么时候应该扩大窗口？
- 什么时候应该缩小窗口？
- 什么时候应该更新答案？

#### [代码模板](https://labuladong.online/algo/essential-technique/sliding-window-framework/#%E5%9B%9B%E3%80%81%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2)

```python
left，right = 0, 0 # 左闭右开
windows=xxx # 无重复字符用set()   统计字符频率用Counter字典
while right<len(s):
  	# 1. 加入窗口，同时右移右指针
    windows.add(s[right]) 
    right+=1
    # 2. 进行窗口内数据的一系列更新
    xxx
    
    # 3. 判断左侧窗口是否要收缩
    while left<right and check(xxx):
        # 4. 左侧窗口移出元素，同时左指针右移
        windows.remove(s[left])
        left+=1
        # 进行窗口内数据的一系列更新
        xxx
```

### 3. 查找算法

#### 二分查找

时间复杂度O(logn)  

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1 # 循环不变量 双闭区间
    while left <= right: # 双闭区间左右边界也要判断 需要等号检查最后一个元素
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1  
        else:
            right = mid - 1 
    return -1
```

### 4. 排序算法

#### 快速排序QuickSort

先将一个元素排好序，然后再将剩下的元素排好序。时间复杂度O(nlogn) ，类似二叉树的前序遍历

```python
def partition(nums, left, right):
    """
    分区函数，选择一个基准元素,将数组分为两部分

    :param nums: 待排序的数组
    :param left: 排序的起始索引
    :param right: 排序的结束索引
    :return: 基准元素的最终位置
    """
   # 以 nums[left] 作为基准数
   i,j=left,right
   base = nums[left]
   while i<j: # 等号不需要交换
      while i < j and nums[j] >= base: # 右指针找到第一个小于基准的元素   ！跳过大于等于！
         j -= 1
      while i < j and nums[i] <= base: # 左指针找到第一个大于基准的元素   ！跳过小于等于！
         i += 1
      if i < j: # 每次变动序号，都要判断   交换两者
      	 nums[i], nums[j] = nums[j], nums[i] 
    nums[left], nums[i] = nums[i], nums[left] # 基准元素交换到对应位置，返回基准元素所在下标
    return i
def quicksort(nums, left, right):
    """
    :param nums: 待排序的数组
    :param left: 排序的起始索引
    :param right: 排序的结束索引
    """
    # 终止条件   等号不需要排序
    if left >= right:
      	return 
    i = partition(nums, left, right) # 基准元素的索引 
    quicksort(nums, left, i - 1)  # 左区间排序
    quicksort(nums, i + 1, right)  # 右区间排序
```

#### 堆排序

```python
def findKthLargest(nums, k):
    """
    找到数组中第K个最大的元素。
    
    :param nums: 一个整数数组
    :param k: 要找的第K个最大元素的位置
    :return: 第K个最大的元素
    """
    # 构建最大堆
    def build_max_heap(nums):
        length = len(nums)
        # 从最后一个非叶子节点开始，向上构建最大堆
        for i in range(length//2 - 1, -1, -1):
            max_heapify(nums, length, i)
    
    # 调整堆，使其满足最大堆的性质  如果子节点大于父节点，就交换它们，并递归调整子树。
    def max_heapify(nums, length, i):
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        if left < length and nums[largest] < nums[left]:
            largest = left
        if right < length and nums[largest] < nums[right]:
            largest = right
        if largest != i:
            nums[i], nums[largest] = nums[largest], nums[i]
            max_heapify(nums, length, largest)
    
    build_max_heap(nums) # 构建最大堆
    for i in range(k - 1):
        nums[0], nums[-1] = nums[-1], nums[0]  # 交换堆顶和最后一个元素
        length = len(nums) - 1  # 减少堆的大小
        max_heapify(nums, length, 0)  # 重新调整堆
    return nums[0]  # 返回堆顶元素，即第K个最大的元素

# 示例
nums = [3,2,1,5,6,4]
k = 2
print(findKthLargest(nums, k))  # 输出应该是5，因为5是第二大的元素

```

### 5. 单调栈

```python
def stack(nums):
    n = len(nums)
    result = [0] * n  # 根据题目初始化结果
    stack = []  # 栈中存储索引
    
    for i in range(n):  # 遍历数组
        # 根据条件调整栈顶元素
        while stack and <当前元素与栈顶索引元素满足条件>:
            idx = stack.pop()  # 弹出栈顶
            result[idx] = <根据题目更新结果>
        stack.append(i)  # 当前元素入栈
    
    return result
```

### 6. 矩阵顺时针遍历

```python
# 定义四个边界 
def spiralOrder(matrix):
    if not matrix:
        return []

    # 初始化边界   双闭区间
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1
    
    result = []
    
    while top <= bottom and left <= right:
        # 从左到右遍历该行
        for i in range(left, right + 1): 
            result.append(matrix[top][i])
        top += 1  # 遍历完移到下一行
        
        # 从上到下
        for i in range(top, bottom + 1):
            result.append(matrix[i][right])
        right -= 1
        
        # 从右到左遍历行  !!!先判断是否还有行，等于也可以!!!
        if top <= bottom: 
            for i in range(right, left - 1, -1):
                result.append(matrix[bottom][i])
            bottom -= 1
        
        # 从下到上遍历列   !!!先判断是否还有列 等于也可以!!!
        if left <= right:
            for i in range(bottom, top - 1, -1):
                result.append(matrix[i][left])
            left += 1
    
    return result
```

## 链表

### 1. 插入元素

#### 尾插

1. 保存下一个节点
2. 尾插      旧指None    新指旧
3. 新表更新尾节点
4. 旧表更新头结点

### 2. 翻转链表
思路：pre新链表    cur当前节点     next下一个节点

1. 旧链表保存下一个节点
2. 旧链表当前节点指向新链表头（翻转指针）
3. 新链表更新表头
4. 旧链表更新当前节点

```python
def reverse_linked_list(head):
    """
    :param head: 链表的头节点
    :return: 翻转后的链表头节点
    """
    prev = None  # 上一个节点，初始化为 None
    current = head  # 当前节点，初始化为链表的头节点

    # 遍历链表，直到当前节点为空   
    while current:
        next_node = current.next  # 1. 旧链表保存下一个节点
        current.next = prev  # 2. 将当前节点指向新链表头（翻转指针）
        prev = current  # 3.新链表更新表头
        current = next_node  # 4. 旧链表更新表头

    return prev  # 返回新的头节点
```

### 3. 合并两个有序链表

时间复杂度为 O(m + n)

```python
def merge_two_lists(l1, l2):
    # 创建一个虚拟头节点，方便处理合并操作
    dummy = ListNode(0)
    current = dummy  # 用于遍历和构建合并链表的指针

    # 遍历两个链表，直到其中一个链表为空
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next  # 更新l1表头
        else:
            current.next = l2
            l2 = l2.next  # 更新l2表头
        
        # 更新新链表表头
        current = current.next

    # 将 剩余的节点连到新链表的末尾
    if l1:
        current.next = l1
    if l2:
        current.next = l2

    # 返回合并后的链表，去掉虚拟头节点
    return dummy.next
```

## 二叉树

### 1. 深度优先遍历DFS

#### 递归三步骤

1. 确定递归函数的参数和返回值
2. 确定终止条件
3. 确定单层递归的逻辑

#### 迭代法

[统一写法](https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%9D%E8%B7%AF)      

```
# 用栈实现，所以 倒序。    每次中节点加none
前序：中左右    迭代是右左中
中序：左中右     迭代是右左中   
后序：左右中     迭代是中右左     
```

### 2. 广度优先搜索（BFS）

#### [层序遍历](https://www.programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html#_102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86)

1. 队列 装入当前层
2. 遍历当前层节点
3. 装入当前节点，同时装入对应左右孩子

```python
# 利用长度法
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        # 边界   空数
        if not root:
            return []
        queue = collections.deque([root]) # deque双端队列  装入根节点
        result = []
        while queue: # 1. 遍历每一层
            # 2. 遍历当前层的节点   长度划分出当前层的元素个数，for pop遍历并清空当前层元素
            level = [] 
            nums=len(queue) # queue动态变化，必须先统计长度
            for _ in range(nums): 
                cur = queue.popleft() 
                level.append(cur.val)
                # 3. 装入左右子树
                if cur.left: 
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            result.append(level) # 4. 保存当前层结果
        return result
```

## 图论

### 1. 深度优先遍历

岛屿数量

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        res=0 # 岛屿数量初始化为0
       
        # 遍历grid
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                # 判断当前元素 是否为1，即为岛屿
                if grid[i][j]=="1":
                    # 每发现一个岛屿，岛屿数+1
                    res+=1
                    # 用深度优先遍历DFS将岛屿淹掉
                    self.dfs(grid,i,j)
        return res
    def dfs(self,grid,i,j):
        # 递归终止条件  上下左右四边
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]):
            # 超出索引边界  什么都不操作
            return 
        if grid[i][j]=="0":
            # 已经是海水  什么都不操作
            return 

        # 将（i，j）变为海水
        grid[i][j]="0"
        # 同时递归淹没上下左右陆地
        self.dfs(grid,i-1,j)
        self.dfs(grid,i+1,j)
        self.dfs(grid,i,j-1)
        self.dfs(grid,i,j+1)
```

### 2. 广度优先遍历

腐烂橘子

```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        from collections import deque
        # 1. 统计腐烂橘子坐标，统计新鲜橘子数量
        # 2. 腐烂橘子同时传播一次，减少新鲜橘子数量
        # 3. 全部传播完后判断是否还有新鲜橘子
        deq = deque()  # 保存腐烂橘子
        fresh_nums = 0  # 新鲜橘子的数量

        # 遍历整个网格，初始化腐烂橘子的坐标并统计新鲜橘子的数量
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    fresh_nums += 1  # 统计新鲜橘子
                elif grid[i][j] == 2:
                    deq.append((i, j))  # 添加腐烂橘子的位置
        
        # 如果没有新鲜橘子，直接返回0
        if fresh_nums == 0:
            return 0
        
        # 开始腐烂
        time = 0  # 耗时
        direct = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 上下左右四个方向
        while deq:
            # 当前这波腐烂的橘子数目
            for _ in range(len(deq)):
                x, y = deq.popleft()  # 获取当前腐烂橘子的位置
                # 尝试上下左右传播腐烂
                for dx, dy in direct:
                    nx, ny = x + dx, y + dy
                    # 判断新位置是否有效且是新鲜橘子
                    if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1:
                        grid[nx][ny] = 2  # 将新鲜橘子腐烂
                        fresh_nums -= 1  # 新鲜橘子数量减少
                        deq.append((nx, ny))  # 将新腐烂的橘子加入队列
            time += 1  # 每次while结束，时间增加

        # 最后一次传播是多余的，所以-1

        # 如果还有新鲜橘子，返回-1，否则返回总时间
        return time - 1 if fresh_nums == 0 else -1
```

## 回溯

三步骤

1. 回溯函数模板 参数及返回值

   参数：path存放结果，result存放结果集，startIndex下一层for循环搜索的起始位置

2. 回溯函数终止条件

3. 遍历过程 （思考N叉树，横向遍历什么   纵向遍历什么）

```python
def backtracking(result,path,xxx): 
    if 终止条件:
        result.append(path[:])  # 存放结果 必须[:]返回新列表
        return   #返回
    for i in range(len(xxx)): # 数组左闭右开[ ), 结尾剪枝
        处理当前值
        backtrack(path,result,xxx)  # 如果有startIndex， i表示可重复  i+1不能重复取
        撤销当前值
# 定义全局变量
result,path=[],[]
backtracking(result,path,xxx)
return result 
```

## 动态规划

### 1. 动态规划5步骤

- dp下标定义⭐️⭐️⭐️
- 递推公式
- 初始化
- 遍历顺序
- 举例推导dp数组

### 2. 背包递推公式

- 能否装满背包（或最多装多少）

  ```python
  if nums[i-1] <= j: # 物品i能装入
  	  dp[i][j] = max(dp[i-1][j], dp[i][j-nums[i-1]] + nums[i-1])  
  else: # 无法装入
  	  dp[i][j] = dp[i-1][j]
  ```

- 装满背包有几种方法

  ```python
  if nums[i-1] <= j: # 物品i能装入
    	# dp[i-1][j]：不装入物品i时装满容量为j的方案数
      # dp[i][j - nums[i-1]]：装入物品i时装满容量为j的方案数
  	  dp[i][j] = dp[i-1][j] + dp[i][j - nums[i-1]]
  else: # 无法装入,方案数不增加
  	  dp[i][j] = dp[i-1][j]
  ```

- 背包装满最大价值

  ```python
  for i in range(1, n + 1):  # 先物品
      for j in range(capacity + 1):  # 后容量
          if weights[i - 1]<= j:  # 物品i能装入   物品序号i从1开始，所以i-1才是物品i的价值
            	dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]] + values[i-1])
          else: 
              dp[i][j] = dp[i-1][j]
  ```

- 背包装满最小物品数

  ```python
  for i in range(1, n + 1):  # 先物品
      for j in range(1, target + 1):  # 后容量
          if coins[i - 1] <=j :  # 物品i能装入
              dp[i][j] = min(dp[i-1][j], dp[i][j - coins[i - 1]] + 1)
          else: 
              dp[i][j] = dp[i-1][j]
  ```

  

### 3. 01背包

- 定义：  dp[i] [j]从下标0~i的物品中任取，放入容量为j的背包的最大价值

- 递归公式:   放物品i和不放物品i两种情况

  - 求最大价值

    ```python
    dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])
    ```

  - 求是否刚好装满   

    ```python
    # 初始化全False   任一为True则为True
    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]
    ```

  - 顺序：  先物品i后背包j，即从左到右填充 方便理解

    二维dp

    ```python
    for i in range(1, n): # 先物品
        for j in range(bagweight + 1): # 后背包
            if j < weight[i]:
                dp[i][j] = dp[i-1][j]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])
    ```

    一维dp

    ```python
    for i in range(n):  # 先物品
        for j in range(bagweight, weight[i]-1, -1):  # 后背包
          # 从后往前倒序，每次取得状态不会和之前取得状态重合，以保证物品i只被放入一次。
          dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
    ```

    

### 4. 完全背包

- 求组合（ 无顺序，如凑零钱）：先物品后背包
- 求排列（有顺序）：先背包后物品  （背包容量的每一个值，都是经过 物品a 和 b 的计算，包含了{a, b} 和 {b, a}两种情况）

```python
# 求组合：先物品后背包
def change(self, amount: int, coins: List[int]) -> int:
    # 初始化二维数组 dp，其中 dp[i][j] 表示用前 i 种物品构成金额 j 的方法数
    dp = [[0] * (amount + 1) for _ in range(len(coins) + 1)]
    # 初始化：金额为 0 的组合数为 1（无论有多少种硬币）
    for i in range(len(coins) + 1):
        dp[i][0] = 1

    # 先物品
    for i in range(1, len(coins) + 1):
        # 遍历金额
        for j in range(amount + 1):
            if j >= coins[i - 1]:
                # 当前硬币 coins[i-1] 可用：包含当前硬币和不包含当前硬币的组合数
                dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]
            else:
                # 当前硬币 coins[i-1] 不可用
                dp[i][j] = dp[i - 1][j]

    # 返回使用所有硬币构成金额 amount 的组合数
    return dp[len(coins)][amount]
```
