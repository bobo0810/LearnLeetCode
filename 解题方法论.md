# 解题方法论



## 字符串

### 1. 字符串解码

&quot;3[a]2[bc]&quot;解码为&quot;aaabcbc"

```python
class Solution:
    def decodeString(self, s: str) -> str:
        stack=[] 
        cur_str="" # 存储当前字符串
        cur_num=0 # 存储当前重复数字

        for char in s:
            # 数字  可能出现连续数字
            if char.isdigit():
                cur_num=cur_num*10+int(char)
            # [
            elif char=="[":
                # 入栈  保存之前的字符串 + 将要重复的数字
                stack.append([cur_str,cur_num])
                # 恢复
                cur_str=""
                cur_num=0
            # ]
            elif char =="]":
                # 出栈
                pre_str,nums=stack.pop()
                cur_str=pre_str+ cur_str*nums # 当前字符串是要重复的目标
            # 字母
            else:
                cur_str+=char
        return cur_str
```



## 数组

### 1. 前缀和  区间和

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        # 非单调，要前缀和  
        
        count=0 #记录总数
        cur_sum=0 # 当前前缀和为0
        prefix_count={0:1} # 哈希表，前缀和为0 出现1次

        for num in nums:
            # 更新当前前缀和
            cur_sum+=num
            # 如果满足条件的前缀和 记录总数
            count+=prefix_count.get(cur_sum-k,0)
            # 更新哈希表
            prefix_count[cur_sum]=prefix_count.get(cur_sum,0)+1
        return count
```

### 2. 滑动窗口

四步

（1）队头移出过期索引 

（2）队尾移出小于当前值的索引 

（3）队尾添加当前索引 

（4）满足条件时统计信息

#### 静态窗口

```python
# 遍历字符
for right in range(len(strs)):
    # 持续右进
    # 当前窗口不满足条件时左出
    # 当前窗口满足需求时统计信息
```

#### 动态窗口

```python
left=0
windows=set()  
#  外层循环移动右指针，内层循环移动左指针
for right in range(len(strs)):
    # 判断当前元素strs[right]
    # 当前区间[left,right]不满足条件时，移动左指针直到满足条件
    while left<=right and check(xxx):
        # 左侧窗口移出元素，左指针右移
        windows.remove(strs[left])
        left+=1
    
    # 当前区间[left,right]满足条件时，加入窗口并统计信息
    windows.add(strs[right]) 
```

### 3. 查找算法

#### 二分查找

时间复杂度O(logn)

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1 # 循环不变量 双闭区间
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1  
        else:
            right = mid - 1 
    return -1
```

### 4. 排序算法

#### 快速排序QuickSort

时间复杂度O(nlogn)

```python
def quicksort(arr, low, high):
    """
    :param arr: 待排序的数组
    :param low: 排序的起始索引
    :param high: 排序的结束索引
    """
    if low < high:
        # 获取基准元素的索引
        pivot_index = partition(arr, low, high)

        # 递归排序基准左侧和右侧部分
        quicksort(arr, low, pivot_index - 1)  # 排序左侧
        quicksort(arr, pivot_index + 1, high)  # 排序右侧

def partition(arr, low, high):
    """
    分区函数，选择一个基准元素并将数组分为两部分

    :param arr: 待排序的数组
    :param low: 排序的起始索引
    :param high: 排序的结束索引
    :return: 基准元素的最终位置
    
    总结
    选择基准: 选择数组的最后一个元素作为基准。
    分区过程: 遍历数组，将小于基准的元素移动到左侧。
    放置基准: 将基准元素放到它的正确位置。
    返回值: 返回基准元素的新索引，以便快速排序的递归调用使用。
    """
    pivot = arr[high]  # 选择最后一个元素作为基准
    i = low - 1  # 小于基准的元素的最后一个索引

    # 遍历数组并进行分区
    for j in range(low, high):
        if arr[j] < pivot:
            i = i + 1  # 增加小于基准的元素的索引
            arr[i], arr[j] = arr[j], arr[i]  # 交换元素

    # 将基准元素放到正确的位置
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1  # 返回基准元素的位置
```

#### 堆排序

```python
def findKthLargest(nums, k):
    """
    找到数组中第K个最大的元素。
    
    :param nums: 一个整数数组
    :param k: 要找的第K个最大元素的位置
    :return: 第K个最大的元素
    """
    # 构建最大堆
    def build_max_heap(nums):
        length = len(nums)
        # 从最后一个非叶子节点开始，向上构建最大堆
        for i in range(length//2 - 1, -1, -1):
            max_heapify(nums, length, i)
    
    # 调整堆，使其满足最大堆的性质  如果子节点大于父节点，就交换它们，并递归调整子树。
    def max_heapify(nums, length, i):
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        if left < length and nums[largest] < nums[left]:
            largest = left
        if right < length and nums[largest] < nums[right]:
            largest = right
        if largest != i:
            nums[i], nums[largest] = nums[largest], nums[i]
            max_heapify(nums, length, largest)
    
    build_max_heap(nums) # 构建最大堆
    for i in range(k - 1):
        nums[0], nums[-1] = nums[-1], nums[0]  # 交换堆顶和最后一个元素
        length = len(nums) - 1  # 减少堆的大小
        max_heapify(nums, length, 0)  # 重新调整堆
    return nums[0]  # 返回堆顶元素，即第K个最大的元素

# 示例
nums = [3,2,1,5,6,4]
k = 2
print(findKthLargest(nums, k))  # 输出应该是5，因为5是第二大的元素

```



### 5. 单调栈

```python
def stack(nums):
    n = len(nums)
    result = [0] * n  # 根据题目初始化结果
    stack = []  # 栈中存储索引
    
    for i in range(n):  # 遍历数组
        # 根据条件调整栈顶元素
        while stack and <当前元素与栈顶索引元素满足条件>:
            idx = stack.pop()  # 弹出栈顶
            result[idx] = <根据题目更新结果>
        stack.append(i)  # 当前元素入栈
    
    return result
```

### 6. 矩阵顺时针遍历

```python
# 定义四个边界 
def spiralOrder(matrix):
    if not matrix:
        return []

    # 初始化边界   双闭区间
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1
    
    result = []
    
    while top <= bottom and left <= right:
        # 从左到右遍历该行
        for i in range(left, right + 1): 
            result.append(matrix[top][i])
        top += 1  # 遍历完移到下一行
        
        # 从上到下
        for i in range(top, bottom + 1):
            result.append(matrix[i][right])
        right -= 1
        
        # 从右到左遍历行  先判断行是否越界
        if top <= bottom: 
            for i in range(right, left - 1, -1):
                result.append(matrix[bottom][i])
            bottom -= 1
        
        # 从下到上遍历列   先判断列是否越界
        if left <= right:
            for i in range(bottom, top - 1, -1):
                result.append(matrix[i][left])
            left += 1
    
    return result
```

### 

## 链表

### 1. 插入元素

#### 头插



#### 尾插

1. 保存下一个节点
2. 尾插      旧指None    新指旧
3. 新表更新尾节点
4. 旧表更新头结点

### 2. 翻转链表
思路：保存->翻转->前后移
```python
def reverse_linked_list(head):
    """
    :param head: 链表的头节点
    :return: 翻转后的链表头节点
    """
    prev = None  # 上一个节点，初始化为 None
    current = head  # 当前节点，初始化为链表的头节点

    # 遍历链表，直到当前节点为空   
    while current:
        next_node = current.next  # 保存下一个节点
        current.next = prev  # 将当前节点的next指针指向上一个节点（翻转指针）
        prev = current  # 移动 prev 到当前节点
        current = next_node  # 移动到下一个节点

    return prev  # 返回新的头节点（翻转后的链表头）
```

### 3. 合并两个有序链表

时间复杂度为 O(m + n)

```python
def merge_two_lists(l1, l2):
    # 创建一个虚拟头节点，方便处理合并操作
    dummy = ListNode(0)
    current = dummy  # 用于遍历和构建合并链表的指针

    # 遍历两个链表，直到其中一个链表为空
    while l1 and l2:
        # 比较两个链表的当前节点的值
        if l1.val < l2.val:
            # 如果 l1 的值更小，将 l1 的节点添加到合并链表中
            current.next = l1
            l1 = l1.next  # 移动 l1 指针到下一个节点
        else:
            # 如果 l2 的值更小或相等，将 l2 的节点添加到合并链表中
            current.next = l2
            l2 = l2.next  # 移动 l2 指针到下一个节点
        
        # 移动 current 指针到合并链表的下一个位置
        current = current.next

    # 处理剩余的节点
    # 只需将 l1 或 l2 中剩余的节点连到合并链表的末尾
    if l1:
        current.next = l1
    if l2:
        current.next = l2

    # 返回合并后的链表，去掉虚拟头节点
    return dummy.next
```









## 二叉树

### 1. 深度优先遍历DFS

#### 递归三步骤

1. 确定递归函数的参数和返回值
2. 确定终止条件
3. 确定单层递归的逻辑

#### 迭代法

[统一写法](https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%9D%E8%B7%AF)      

```
# 用栈实现，所以 倒序。    每次中节点加none
前序：中左右    迭代是右左中
中序：左中右     迭代是右左中   
后序：左右中     迭代是中右左     
```

### 2. 广度优先搜索（BFS）

#### [层序遍历](https://www.programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html#_102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86)

```python
# 利用长度法
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        queue = collections.deque([root]) # deque双端队列  装入根节点
        result = []
        while queue: # 1. 遍历每一层
            # 2. 遍历当前层的节点   长度划分出当前层的元素个数，for pop遍历并清空当前层元素
            level = [] 
            nums=len(queue) # queue动态变化，必须先统计长度
            for _ in range(nums): 
                cur = queue.popleft() 
                level.append(cur.val)
                # 3. 装入左右子树
                if cur.left: 
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            result.append(level) # 4. 保存当前层结果
        return result
```

```python
#递归法
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: #边界
            return []
        levels = []
        def traverse(node, level): # 1. 确定参数和返回值   level指第几层 0~n-1
            if not node: # 2. 终止条件
                return
             # 3. 单层递归逻辑
            if len(levels) == level: #level从0开始   len从1开始。 如果不同，需要初始化新的一层
                levels.append([])
            levels[level].append(node.val)
            traverse(node.left, level + 1)
            traverse(node.right, level + 1)
        traverse(root, 0)
        return levels
```



## 图论

### 1. 深度优先遍历

岛屿数量

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        res=0 # 岛屿数量初始化为0
       
        # 遍历grid
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                # 判断当前元素 是否为1，即为岛屿
                if grid[i][j]=="1":
                    # 每发现一个岛屿，岛屿数+1
                    res+=1
                    # 用深度优先遍历DFS将岛屿淹掉
                    self.dfs(grid,i,j)
        return res
    def dfs(self,grid,i,j):
        # 递归终止条件  上下左右四边
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]):
            # 超出索引边界  什么都不操作
            return 
        if grid[i][j]=="0":
            # 已经是海水  什么都不操作
            return 

        # 将（i，j）变为海水
        grid[i][j]="0"
        # 同时递归淹没上下左右陆地
        self.dfs(grid,i-1,j)
        self.dfs(grid,i+1,j)
        self.dfs(grid,i,j-1)
        self.dfs(grid,i,j+1)
```

### 2. 广度优先遍历

腐烂橘子

```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        from collections import deque
        # 1. 统计腐烂橘子坐标，统计新鲜橘子数量
        # 2. 腐烂橘子同时传播一次，减少新鲜橘子数量
        # 3. 全部传播完后判断是否还有新鲜橘子
        deq = deque()  # 保存腐烂橘子
        fresh_nums = 0  # 新鲜橘子的数量

        # 遍历整个网格，初始化腐烂橘子的坐标并统计新鲜橘子的数量
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    fresh_nums += 1  # 统计新鲜橘子
                elif grid[i][j] == 2:
                    deq.append((i, j))  # 添加腐烂橘子的位置
        
        # 如果没有新鲜橘子，直接返回0
        if fresh_nums == 0:
            return 0
        
        # 开始腐烂
        time = 0  # 耗时
        direct = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 上下左右四个方向
        while deq:
            # 当前这波腐烂的橘子数目
            for _ in range(len(deq)):
                x, y = deq.popleft()  # 获取当前腐烂橘子的位置
                # 尝试上下左右传播腐烂
                for dx, dy in direct:
                    nx, ny = x + dx, y + dy
                    # 判断新位置是否有效且是新鲜橘子
                    if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1:
                        grid[nx][ny] = 2  # 将新鲜橘子腐烂
                        fresh_nums -= 1  # 新鲜橘子数量减少
                        deq.append((nx, ny))  # 将新腐烂的橘子加入队列
            time += 1  # 每次while结束，时间增加

        # 最后一次传播是多余的，所以-1

        # 如果还有新鲜橘子，返回-1，否则返回总时间
        return time - 1 if fresh_nums == 0 else -1
```

## 回溯

三步骤

1. 回溯函数模板 参数及返回值

   参数：path存放结果，result存放结果集，startIndex下一层for循环搜索的起始位置

2. 回溯函数终止条件

3. 遍历过程 （思考N叉树，横向遍历什么   纵向遍历什么）

```python
def backtracking(result,path,xxx): 
    if 终止条件:
        result.append(path[:])  # 存放结果 必须[:]返回新列表
        return   #返回
    for i in range(len(xxx)): # 数组左闭右开[ ), 结尾剪枝
        处理当前值
        backtrack(path,result,xxx)  # 如果有startIndex， i表示可重复  i+1不能重复取
        撤销当前值
# 定义全局变量
result,path=[],[]
backtracking(result,path,xxx)
return result 
```

## 动态规划

### 1. 动态规划5步骤

- dp下标定义⭐️⭐️⭐️
- 递推公式
- 初始化
- 遍历顺序
- 举例推导dp数组

### 2. 背包递推公式

- 能否装满背包（或最多装多少）

  ```python
  if nums[i-1] <= j: # 物品i能装入
  	  dp[i][j] = max(dp[i-1][j], dp[i][j-nums[i-1]] + nums[i-1])  
  else: # 无法装入
  	  dp[i][j] = dp[i-1][j]
  ```

- 装满背包有几种方法

  ```python
  if nums[i-1] <= j: # 物品i能装入
    	# dp[i-1][j]：不装入物品i时装满容量为j的方案数
      # dp[i][j - nums[i-1]]：装入物品i时装满容量为j的方案数
  	  dp[i][j] = dp[i-1][j] + dp[i][j - nums[i-1]]
  else: # 无法装入,方案数不增加
  	  dp[i][j] = dp[i-1][j]
  ```

- 背包装满最大价值

  ```python
  for i in range(1, n + 1):  # 先物品
      for j in range(capacity + 1):  # 后容量
          if weights[i - 1]<= j:  # 物品i能装入   物品序号i从1开始，所以i-1才是物品i的价值
            	dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]] + values[i-1])
          else: 
              dp[i][j] = dp[i-1][j]
  ```

- 背包装满最小物品数

  ```python
  for i in range(1, n + 1):  # 先物品
      for j in range(1, target + 1):  # 后容量
          if coins[i - 1] <=j :  # 物品i能装入
              dp[i][j] = min(dp[i-1][j], dp[i][j - coins[i - 1]] + 1)
          else: 
              dp[i][j] = dp[i-1][j]
  ```

  

### 3. 01背包

- 定义：  dp[i] [j]从下标0~i的物品中任取，放入容量为j的背包的最大价值

- 递归公式:   放物品i和不放物品i两种情况

  - 求最大价值

    ```python
    dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])
    ```

  - 求是否刚好装满   

    ```python
    # 初始化全False   任一为True则为True
    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]
    ```

  - 顺序：  先物品i后背包j，即从左到右填充 方便理解

    二维dp

    ```python
    for i in range(1, n): # 先物品
        for j in range(bagweight + 1): # 后背包
            if j < weight[i]:
                dp[i][j] = dp[i-1][j]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])
    ```

    一维dp

    ```python
    for i in range(n):  # 先物品
        for j in range(bagweight, weight[i]-1, -1):  # 后背包
          # 从后往前倒序，每次取得状态不会和之前取得状态重合，以保证物品i只被放入一次。
          dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
    ```

    

### 4. 完全背包

- 求组合（ 无顺序，如凑零钱）：先物品后背包
- 求排列（有顺序）：先背包后物品  （背包容量的每一个值，都是经过 物品a 和 b 的计算，包含了{a, b} 和 {b, a}两种情况）

```python
# 求组合：先物品后背包
def change(self, amount: int, coins: List[int]) -> int:
    # 初始化二维数组 dp，其中 dp[i][j] 表示用前 i 种物品构成金额 j 的方法数
    dp = [[0] * (amount + 1) for _ in range(len(coins) + 1)]
    # 初始化：金额为 0 的组合数为 1（无论有多少种硬币）
    for i in range(len(coins) + 1):
        dp[i][0] = 1

    # 先物品
    for i in range(1, len(coins) + 1):
        # 遍历金额
        for j in range(amount + 1):
            if j >= coins[i - 1]:
                # 当前硬币 coins[i-1] 可用：包含当前硬币和不包含当前硬币的组合数
                dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]
            else:
                # 当前硬币 coins[i-1] 不可用
                dp[i][j] = dp[i - 1][j]

    # 返回使用所有硬币构成金额 amount 的组合数
    return dp[len(coins)][amount]
```
