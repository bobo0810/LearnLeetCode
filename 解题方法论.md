# 解题方法论



## 数组

### 1. 前缀和、区间和

- 前缀和：明确定义，即是否包含当前元素、遍历的范围

- 哈希表 {前缀和：出现次数}，初始化为{0:1}   表示前缀和为0出现了1次，避免漏掉从数组开头开始的子数组

### 2. 查找算法

#### 二分查找

- 时间复杂度O(logn)     
- 如果没有，**left**指向目标被插入的位置

##### 1. 查找目标值

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1 # 循环不变量 双闭区间
    while left <= right: # 双闭区间左右边界也要比较 
        mid = (left + right) // 2
        # 不要else 必须所有情况列出来
        if nums[mid] < target: 
            left = mid + 1  
        elif nums[mid] > target:
            right = mid - 1 
        elif nums[mid] == target:
            return mid
    return -1 # 如果没有，left指向目标被插入的位置
```

##### 2. 寻找目标值的左右边界
```python
# 在排序数组中查找元素的第一个和最后一个位置下标，即寻找左侧边界 和 右边界
def search(nums, target) -> int:
    # ------左边界------
    left,right=0,len(nums)-1 
    final_left=-1 # 记录结果，持续更新
    while left<=right:
        mid=(left+right)//2
        if nums[mid]>target:
            right=mid-1
        elif nums[mid]<target:
            left=mid+1
        elif nums[mid]==target:
            final_left=mid 
            right=mid-1  # 寻找左边界 要收缩右边界，唯一区别
      
    # ------右边界------
    left,right=0,len(nums)-1 
    final_right=-1 
    while left<=right: 
        mid=(left+right)//2
        if nums[mid]>target:
            right=mid-1
        elif nums[mid]<target:
            left=mid+1
        elif nums[mid]==target:
            final_right=mid
            left=mid+1  # 寻找右边界  就要收缩左边界，唯一区别
       
    return [final_left,final_right] # 找不到返回[-1,-1]
```


##### 3. 旋转排序数组❓

[4, 5, 6, 7, 0, 1, 2]

- 搜索目标值：根据左右区间的有序性和目标值范围调整指针
- 寻找最小值：只需比较中点与右端点

##### 4. 寻找两个正序数组的中位数❓



### 3. 排序算法

#### 快速排序QuickSort

时间复杂度O(nlogn) 

1. 确定基准值，左侧找小于基准值，右侧找大于基准值，持续交换
2. 将基准值 左右区间，递归排序。

```python
def swap(nums, left, right):
    """
    分区 选择一个基准元素,将数组分为两部分
    """
   # 以 nums[left] 作为基准数
   i,j=left,right
   base = nums[left]
   while i<j: # 等号无需交换
      while i < j and nums[i] <= base: # 左指针找到第一个大于基准的元素，准备交换
         i += 1
      while i < j and base <= nums[j]: # 右指针找到第一个小于基准的元素，准备交换  
         j -= 1
      if i < j: # 下标每次变动，都要判断
      	 nums[i], nums[j] = nums[j], nums[i] 
    nums[left], nums[i] = nums[i], nums[left] # 基准元素交换到对应位置，返回基准元素所在下标
    return i
def quicksort(nums, left, right):
    """
    :param nums: 待排序的数组
    :param left: 排序的起始索引
    :param right: 排序的结束索引
    """
    # 终止条件   等号不需要排序
    if left >= right:
      	return 
    base_index = swap(nums, left, right) # 分区，返回基准值对应下标 
    quicksort(nums, left, base_index - 1)  # 左区间排序
    quicksort(nums, base_index + 1, right)  # 右区间排序
```

#### 堆排序Heap

[堆排序 核心思想](https://www.hello-algo.com/chapter_heap/heap/#3)  搞懂「堆化」、「建堆」和「出堆」的过程。 整体流程如下：

1. 堆化（递归）：从当前下标向下全部堆化

   1. 参数和返回值：3个入参  nums数组、length堆长度、i待堆化的下标

   2. 终止条件 （1）当前为叶子节点 （2）当前非叶子节点，但相比左右孩子已是最大值，无需交换

      ```python
      left,right=2* i+1, 2*i+2  # 左右孩子下标
      ```

   3. 单层递归逻辑：当前值 与最大值交换，继续向下堆化

2. 建最大堆：从最后一个非叶子节点开始到根节点，构建最大堆

   ```python
   length//2-1  # 最后一个非叶子节点的下标
   ```

3. 出堆：移除k-1个元素，堆顶就是第k大的元素

   1. 交换堆顶和堆底元素 
   2.  堆长度-1，堆顶执行堆化

- tips:

  (1)大小顶堆唯一区别是堆化时比较当前节点 > or <孩子。 

详见 [高频题-查找数组第K大的元素](高频题.md)

### 4. 滑动窗口

#### 滑动窗口三步骤

- 什么时候扩大窗口？
- 什么时候缩小窗口？
- 什么时候更新答案？

#### 1. 解题2步骤

1. 初始化参数 

   （1）滑动窗口参数：windows={}   标识符valid=0     left,right=0,0**左开右闭**，避免边界问题

   （2）子串参数need： 无重复字符用集合set()、统计字符频率用Counter

   （3）记录结果参数

2. 遍历字符串 right<len(s)   right是即将遍历的下标

   （1）判断当前元素 更新窗口、标识符，同时扩大右边界

   （2）判断是否收缩窗口

   ​	     固定窗口判断条件  窗口已满 `if right-left>= len(子串)`

   ​		 动态窗口判断条件  合法区间内满足子串条件  `while left<right and valid==len(need.keys())`

   （3）收缩两步骤  （a）记录当前结果（b）左侧窗口移出元素，同时缩小左边界

```python
# 最小覆盖子串  
def minWindow(self, s: str, t: str) -> str:
    
    # 窗口参数
    window = {} 
   	valid=0 # 单字符满足频次时+1   值等于need长度时满足条件
  	left，right, = 0,0 # 左闭右开[left,right)   区间[0, 0)中没有元素，避免边界问题  窗口长度=right-left
    
    # 子串参数   
    from collections import Counter
    need=Counter(t) # "eex" --> Counter({'e': 2, 'x': 1})

    # 记录结果
    strat=0
    length=float("inf")
   
    while right<len(s):  # right是待处理的索引，取值范围是0~n-1    此时窗口内范围是left~right-1
        # 1. 判断当前元素 是否加入窗口,并更新标识符
        char=s[right] 
        if char in need.keys():
            window[char] = window.get(char, 0) + 1
            if window[char] == need[char]:
                 valid += 1 
				# 2. 扩大右边界
        right+=1
        
        # 3. 判断是否收缩窗口
        while left<right and valid==len(need.keys()): 
            # 4. 记录结果
            if right-left<length:
              	start=left
                length=right-left
            # 5. 判断当前左侧元素是否移出窗口
            char = s[left]
            if char in need.keys():
              	if window[char] == need[char]:
                    valid-=1
                window[char]-=1
            # 6. 收缩左边界
            left+=1
		return "" if length==float("inf") else s[start: start + length]
```

[links](https://labuladong.online/algo/essential-technique/sliding-window-framework/#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88)

```python
无重复字符的最长子串: 找出其中不含有重复字符的最长子串的长度。  set  add  remove
输入: s = "abcabcbb"  输出: 3,即"abc" 

# 动态窗口
# 1. 什么时候扩大窗口？ 每步都在扩大
# 2. 什么时候收缩窗口？ 窗口内都是不重复元素，如果当前右侧元素在窗口内出现重复值，一直收缩左侧元素直到窗口内不重复
# 3. 什么时候更新结果？ 收缩完记录结果
```



### 5. 单调栈

#### 单调栈3步骤

1. list模拟栈，明确 当前元素  和 栈顶元素 的><=三种情况
2. 无论栈怎么改变，当前元素都要入栈
3. 栈 存放元素下标

```python
result = [0] * len(nums)  # 根据题目初始化结果
stack = []  # 栈存下标

for i in range(nums): 
    while stack and <当前元素与栈顶元素满足条件>:
        idx = stack.pop()  # 弹出
        result[idx] = <根据题目更新结果>
    stack.append(i)  # 当前元素入栈

return result
```

### 6. 螺旋矩阵

思路：

1. 从外到内，一圈一圈顺时针遍历
2. 4个指针定义边界  top bottom  left right
3. **逆序遍历**时判断是否存在，即右边向左边需判断是否有该行、下面向上边 需判断是否有该列

```python
# 定义四个边界 
def spiralOrder(matrix):
    if not matrix:
        return []

    # 初始化边界   双闭区间
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1
    
    result = []
    
    while top <= bottom and left <= right:
        # 从左到右遍历该行
        for i in range(left, right + 1): 
            result.append(matrix[top][i])
        top += 1  # 遍历完移到下一行
        
        # 从上到下
        for i in range(top, bottom + 1):
            result.append(matrix[i][right])
        right -= 1
        
        # 从右到左遍历行  !!!先判断是否还有行!!!
        if top <= bottom: 
            for i in range(right, left - 1, -1):
                result.append(matrix[bottom][i])
            bottom -= 1
        
        # 从下到上遍历列   !!!先判断是否还有列!!!
        if left <= right:
            for i in range(bottom, top - 1, -1):
                result.append(matrix[i][left])
            left += 1
    
    return result
```

## 链表

核心解法：  （1）快慢指针  （2）虚拟头结点  

### 1. 插入元素

#### 尾插

1. 保存下一个节点
2. 尾插      旧指None    新指旧
3. 新表更新尾节点
4. 旧表更新头结点

### 2. 翻转链表
思路：三个节点  新链表表头new_node   旧链表当前节点cur_node    旧链表下一个节点next_node

1. 保存旧链表下一个节点
2. 旧链表当前节点指向新链表头 
3. 更新新链表表头
4. 更新旧链表

```python
def reverse_linked_list(head):
    new_node = None  # 新链表 初始化为None
    cur_node = head  # 当前节点，初始化为链表的头节点

    # 遍历链表，直到当前节点为空   
    while cur_node:
        next_node = cur_node.next  # 1. 保存旧链表下一个节点
        cur_node.next = new_node  # 2. 将当前节点指向新链表头
        new_node = cur_node  # 3.新链表更新表头
        cur_node = new_node  # 4. 旧链表更新表头
    return new_node  # 返回新的头节点
```

### 3. 合并两个有序链表

时间复杂度为 O(m + n)

```python
def merge_two_lists(l1, l2):
    # 创建一个虚拟头节点，方便处理合并操作
    dummy = ListNode(0)
    cur_node = dummy  # 用于遍历和构建合并链表的指针

    # 遍历两个链表，直到其中一个链表为空
    while l1 and l2:
        if l1.val < l2.val:
            cur_node.next = l1
            l1 = l1.next  # 更新l1表头
        else:
            current.next = l2
            l2 = l2.next  # 更新l2表头
        
        # 更新新链表表头
        cur_node = cur_node.next

    # 剩余的节点接到新链表的末尾
    if l1:
        cur_node.next = l1
    if l2:
        cur_node.next = l2

    # 返回合并后的链表，去掉虚拟头节点
    return dummy.next
```

## 二叉树

### 1. 深度优先遍历DFS

#### 递归三步骤

1. 确定递归函数的参数和返回值
2. 确定终止条件
3. 确定单层递归的逻辑

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        
        def dfs(node):
            if node is None:
                return   
            # 前序  中左右
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
            
            # 中序  左中右
            #dfs(node.left)
            #res.append(node.val)
            #dfs(node.right)
            
            # 后续  左右中
            #dfs(node.left)
            #dfs(node.right)   
            #res.append(node.val)
        dfs(root)
        return res
```

### 2. 广度优先搜索（BFS）

#### [层序遍历](https://www.programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html#_102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86)

1. 初始化队列 ,装入根节点
2. 遍历当前层节点
3. 记录当前节点，同时装入对应左右孩子
4. 装入当前层所有节点值

```python
# 利用长度法
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        # 边界条件   空树
        if not root:
            return []
        queue = collections.deque([root]) # deque双端队列  装入根节点
        result = []
        while queue: # 1. 遍历每一层
            # 2. 遍历当前层的节点   长度划分出当前层的元素个数，for pop遍历并清空当前层元素
            level = [] 
            nums=len(queue) # queue动态变化，必须先统计长度
            for _ in range(nums): 
                cur = queue.popleft() 
                level.append(cur.val)
                # 3. 装入左右子树
                if cur.left: 
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            result.append(level) # 4. 保存当前层结果
        return result
```

## 回溯

### 1. 回溯三步骤

1. 确定传参

   - 全局参数：path存放结果，result存放结果集

   - 局部参数：求组合用startIndex，求排列用used

2. 确定终止条件    保存结果**必须复制**

3. 遍历时必须**明确**for横向遍历什么和取值范围    纵向递归遍历什么和取值范围    path存的什么）

### 2. 应用

### （1）子集  startIndex，先记录结果再终止条件

```python
# leetcode78 给定数组，返回所有可能的子集
result，path = [],[] # 全局参数
def backtracking(nums,startIndex):
    result.append(path.copy())  # 记录结果，前序位置每个节点的值都是一个子集
    if startIndex == len(nums):  # 终止条件
        return
    for i in range(startIndex, len(nums)): 
        path.append(nums[i])
        backtracking(nums, i+1) # 递归 i控制纵向遍历位置。i+1不能重复取
        path.pop()
startIndex=0
backtracking(nums,startIndex)
return result
```

[Links](https://www.programmercarl.com/0078.%E5%AD%90%E9%9B%86.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)

### （2）组合  startIndex

组合无序

```python
result，path = [],[] # 全局参数
def backtracking(nums,startIndex):
    if 终止条件:  # 长度 or 总和等于指定值
        result.append(path.copy())  # 存放结果 !必须复制!
        return 
    for i in range(startIndex,len(nums)): # 横向遍历的起始位置
        path.append(nums[i])
        backtrack(nums,i)  #递归 i控制纵向遍历位置，依赖于横向。i表示可重复,i+1不能重复取(画出N叉树就明白了)
        path.pop()
startIndex=0 
backtracking(nums,startIndex)
return result 
```

### （3）切割  startIndex

- 如何模拟那些切割线？ 类似组合， startIndex代表切割线   
- 终止条件？切完整个字符串,即**startIndex== len(s)**
- 在递归循环中如何截取子串？s[startIndex: i+1]代表下标startIndex~i  刚切出来，左开右闭
- 如何判断回文？ s==s[::-1]

```python
# 131.分割回文串: 分割成子串，每个子串都是回文串
result，path = [],[]  # 全局参数存结果
def backtracking(s,startIndex):
    # 终止条件
    if startIndex == len(s):
        result.append(path.copy()) # 切完说明整个字符串切成回文  必须复制
        return
    for i in range(startIndex, len(s)): # i取值0~n-1
      	strr=s[startIndex:i+1]  # 切出来的子串
        if strr == strr[::-1]: # 如果回文，才继续剩余部分的切分 
            path.append(strr)
            backtracking(s, i+1) # 纵向 从下一字符切割，判断其余是否仍为回文串
            path.pop() # 回溯
startIndex=0 # 切割线
backtracking(s,startIndex)
return result
```

[links](https://www.programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

### （4）排列  used，无startIndex

排列有序，需要穷举元素的位置  用**used**标记还可以选择哪些元素

```python
# leetcode46 全排列
result,path=[],[] # 全局参数
def backtrack(nums,used):
    # 终止条件
    if len(path)==len(nums):
        result.append(path.copy()) # 复制结果
        return
    
    for i in range(len(nums)):
        if used[i]==True:
            continue # 跳过已访问的元素
        else:
            path.append(nums[i])
            used[i]=True
            backtrack(nums,used) # 纵向每次遍历整个数组，带着used
            path.pop()
            used[i]=False
used=[False]*len(nums) 
backtrack(nums,used) # 求排列有序 跳过已使用过的元素
return result
```

## 图论

### 1. 深度优先遍历3步骤

1. 递归参数：    grid、当前坐标i和j
2. 递归终止条件：    （1）上下左右四边越界（2）当前位置已经是海水
3. 单层递归逻辑： 当前位置变为海水，再递归淹没上下左右

```python
# 岛屿数量
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        res=0 # 岛屿数量初始化为0
       
        # 遍历grid
        for i in range(len(grid)):
            for j in range(len(grid[0])):  
                if grid[i][j]=="1": # 发现岛屿
                    res+=1 # 岛屿数+1
                    self.dfs(grid,i,j) # 将岛屿周围淹掉
        return res
    def dfs(self,grid,i,j):
        # 递归终止条件 （1）上下左右四边越界 （2）当前已是海水
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]):
            return 
        if grid[i][j]=="0": 
            return 

        
        grid[i][j]="0" # 淹没当前位置
        # 再递归淹没上下左右
        self.dfs(grid,i-1,j)
        self.dfs(grid,i+1,j)
        self.dfs(grid,i,j-1)
        self.dfs(grid,i,j+1)
```

### 2. 广度优先遍历3步骤

1. 队列装入腐烂橘子坐标，同时统计新鲜橘子数量
2. 遍历第一波，所有腐烂橘子同时上下左右传播一次，减少新鲜橘子数量。将新传染的橘子装入队列，进行下一波传染。
3. 全部传播完后判断是否还有新鲜橘子

```python
# 腐烂橘子
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        from collections import deque
        deq = deque()  # 保存腐烂橘子
        fresh_nums = 0  # 新鲜橘子的数量

        # 遍历整个网格，初始化腐烂橘子的坐标并统计新鲜橘子的数量
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    fresh_nums += 1  # 统计新鲜橘子
                elif grid[i][j] == 2:
                    deq.append((i, j))  # 添加腐烂橘子的位置
        
        # 如果没有新鲜橘子，直接返回0
        if fresh_nums == 0:
            return 0
        time = 0  # 耗时
        direct = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 上下左右四个方向
        while deq: # 开始第一波腐烂
            for _ in range(len(deq)):
                x, y = deq.popleft()  # 当前腐烂橘子的位置
                # 尝试上下左右传播腐烂
                for dx, dy in direct:
                    nx, ny = x + dx, y + dy
                    # 判断新位置处于合法区间，且是否为新鲜橘子
                    if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1:
                        grid[nx][ny] = 2  # 1.将新鲜橘子腐烂
                        fresh_nums -= 1  # 2.新鲜橘子数量减少
                        deq.append((nx, ny))  # 3.将新腐烂的橘子加入第二波队列
            time += 1  # 第一波传染完毕，次数+1

				if fresh_nums == 0:
          	return time-1  #最后一次传播是多余的，所以-1
        else:
          	return -1  # 如果还有新鲜橘子，返回-1
```



## 贪心

1. 无套路，千题千法，故不要在意数学证明。 
2. 思路：想清楚局部最优，想清楚全局最优，感觉可以推出，且想不出反例

## 动态规划

### 1. 动态规划5步骤

1. dp下标定义⭐️⭐️⭐️       明确下标 i 取值范围、总长度，以及对应元素的取值范围

2. 递推公式      更新依赖于哪些因素

3. 初始化

4. 遍历顺序     先物后背，谐音**吾辈**当自强    求排列（特例，先背后物）

5. 举例推导数组    

- 背包问题tips：
  - 背包容量从0开始
  - 一维dp    01背包时内层倒序，避免重复；完全背包时内层正序，需要重复取。
  - 求排列是特例，先物品后背包

### 2. 01背包

<img src="assets/image-20241211001418031.png" alt="image-20241211001418031" style="zoom:30%;" />

#### （1）[二维dp](https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)
1. dp 定义：dp[i] [j]从前i个物品中任取，放入容量为j的背包的最大价值。
2. 递推公式


3. 初始化：填充第一行、第一列

   ```python
   # 初始化  背包从容量0开始填充，故+1   物品不变
   dp = [[0] * (capacity + 1) for _ in range(n)]
   for j in range(weight[0], capacity + 1):
       dp[0][j] = value[0]
   ```


#### （2）[一维dp](https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

1. dp定义:  dp[j] 容量为j的背包，所背的物品最大价值

2. 递推公式:   不放物品i和放物品i两种情况

   ```python
   dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
   ```

3. 初始化

   ```python
   dp = [0] * (capacity + 1)  # 初始值为0，背包容量从0开始，故+1
   dp[0] = 0  # 背包容量为0，最大价值为0
   ```

#### （3）应用场景

##### 1. 只取一次的背包最大价值

```python
# ===========二维dp===========
for i in range(1, n):  # 先物品  物品0已填充,后续取值范围1~n-1 
    for j in range(capacity + 1):  # 后背包  取值范围 空背包0~满背包n
        if j >= weights[i]: 
          	dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i]] + values[i])
        else: 
            dp[i][j] = dp[i-1][j]
     
    
# ===========一维dp===========
for i in range(n): # 先物品
    for j in range(capacity, 0, -1):  # 后背包 逆序
      	if j>=weight[i]:
             dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) # 每次状态不会和之前重合，保证物品i只被放入一次。
```

##### 2. 背包是否刚好装满

[分割等和子集](https://www.programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)   正好凑出sum/2    求组合 

```python
total_sum = sum(nums)
if total_sum % 2 != 0: # 总和的一半 能被2整除
    return False

target_sum = total_sum // 2
dp = [False] * (target_sum + 1) 
dp[0] = True

for num in nums: # 先物品
    for i in range(target_sum, 0, -1): # 后背包 逆序
        # 判断背包容量是否装入物品
        if i>=num:
        		dp[i] = dp[i] or dp[i - num]
return dp[target_sum]

```

### 3. 完全背包

唯一区别  **内层正序遍历**，保证物品重复放入

##### 1. 无限取的背包最大价值

```python
dp = [0] * (bagWeight + 1)
for i in range(len(weight)):  # 物品
    for j in range(weight[i], bagWeight + 1):  #背包容量  取值范围 物品i重量~背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
```

##### 2. 求组合无序，例零钱兑换

##### 3. 求排列有序，例 爬楼梯有几种方法

 爬楼梯进阶： n 阶台阶，每次爬m (1 <= m < n)，有多少种不同的方法？

​	**唯一特例 先背包后物品** （背包容量的每一个值，都是经过 物品a 和 b 的计算，包含了{a, b} 和 {b, a}两种情况）

```python
# 递推公式  dp[j]依赖于dp[j-1]，dp[j-2]，dp[j-3]等，即dp[j-i]
dp = [0]*(n+1) # 背包总容量
dp[0] = 1 

for j in range(1,n+1): # 先背包  
    for i in range(1,m+1): # 后物品
        if j>=i:
            dp[j] += dp[j-i] # 这里i就是重量而非index
return dp[n]
```

##### 4. 求背包装满最小物品数

```python
dp = [float('inf')] * (amount + 1)   # 求最小，故初始值无穷大
dp[0]=0 # 容量为0，则最小物品数为0

for i in range(n):  # 先物品 取值范围0~n-1
    for j in range(1, target + 1):  # 后背包   取值范围1~背包容量
        if j >= coins[i]:  # 物品i能装入
            dp[j] = min( dp[j]，dp[j - coins[i]] + 1)
return -1 if dp[amount]==float("inf") else dp[amount]
```



