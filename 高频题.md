

# 高频题

## 数组

### 1. 三数之和⭐️

思路：（1）排序 + 左右指针  （2）基准 和 记录结果时过滤重复值

​    [links](https://www.programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        result = []
        nums.sort()
        for i in range(len(nums)-2): # 0~n-3  必须三个数
            # # 第二个元素开始 判断当前元素与之前元素重复则跳过
            if i > 0 and nums[i] == nums[i - 1]:
                continue
                
            left，right = i + 1，len(nums) - 1
            while left<right: # 不要等号  必须三个数
                total = nums[i] + nums[left] + nums[right]
                if total < 0:
                    left += 1
                elif total > 0:
                    right -= 1
                else:
                    result.append([nums[i], nums[left], nums[right]]) # 记录一组解
                    
                    # 两者都判断下一个元素，过滤相同解
                    while left<right and nums[right] == nums[right-1]:
                        right -= 1
                    while left<right and nums[left] == nums[left+1]:
                        left += 1
                    # 走到相同元素的边界，再走一步
                    right -= 1
                    left += 1
        return result
```



### 2. 接雨水

双指针思路： 1. 构建左最大值数组，包含自身  2. 右最大数组  3. 计算接水量，注意两侧柱子不存水

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 边界条件
        if len(height)<3:
            return 0
        
        # 1. 构建左最大
        left_max=[0]*len(height)
        left_max[0]=height[0]
        for i in range(1,len(height)): 
            left_max[i]=max(left_max[i-1],height[i])
        
        # 2. 构建右最大
        right_max=[0]*len(height)
        right_max[-1]=height[-1]
        for i in range(len(height)-2,-1,-1):
            right_max[i]=max(right_max[i+1],height[i])
        # 3. 计算接水量
        count=0
        for i in range(1,len(height)-1):
            count+=max(min(left_max[i],right_max[i])-height[i],0)
        return count
```



### 3. 数组中的第K个最大元素

```python
# 查找数组第K大的元素
def findKthLargest(nums, k):
    # 1. 堆化  从当前元素自顶向下全部递归堆化
    def max_heap(nums,length,i):
        # 2个终止条件 （1）叶子节点 （2）当前节点非叶子节点，但已是最大值，无需交换
        left,right=2*i+1,2*i+2 # 左右孩子
        if left>=length and right>=length:  # 没有孩子，属于叶子结点
            return 
				
        # 合理区间内最大值下标  判断是否需要交换
        largest=i
        if left<length and nums[largest]<nums[left]:  
            largest=left
        if right<length and nums[largest]<nums[right]:
            largest=right
        if largest==i: 
            return

        #  单层递归逻辑  交换并向下持续堆化
        nums[i],nums[largest]=nums[largest],nums[i]
        max_heap(nums,length,largest)

    # 2. 建堆：从最后一个非叶子节点开始到根节点，构建最大堆
    def build_max_heap(nums):
        length=len(nums)
        for i in range(length//2-1,-1,-1): # 最后一个非叶子节点 --> 根节点
            max_heap(nums,length,i)
    build_max_heap(nums)

    # 3. 出堆  移除k-1个元素，堆顶就是第k大的元素
    for i in range(len(nums)-1,len(nums)-k,-1): # 左闭右开，差值就是元素个数
        # （1）交换堆顶和堆底元素  （2）缩小堆范围 从根节点堆化
        nums[0],nums[i]=nums[i],nums[0]
        # i指堆范围，持续缩小堆范围 堆结尾从n-1缩小为n-k+1,代表移除k-1个元素
        max_heap(nums,i,0) 
    return nums[0]
# 示例
nums = [3, 2, 1, 5, 6, 4]
k = 2
print(findKthLargest(nums, k))  # 输出应该是 5
```



## 二分查找

pass

## 栈

### 1. 字符串解码

&quot;3[a]2[bc]&quot;解码为&quot;aaabcbc"

```python
class Solution:
    def decodeString(self, s: str) -> str:
        stack=[] 
        cur_str="" # 存储已解码的字符串
        cur_num=0 # 存储即将解码的数字

        for char in s: # char4种可能
            if char.isdigit(): # 连续数字
                cur_num=cur_num*10+int(char)
            elif char=="[":
                # 入栈  保存已解码的字符串 + 即将解码的数字
                stack.append([cur_str,cur_num])
                # 清空
                cur_str=""
                cur_num=0
            elif char =="]":
                # 出栈
                pre_str,nums=stack.pop()
                cur_str=pre_str+ cur_str*nums # 当前字符串是要重复的目标
            else:
                cur_str+=char # 字母
        return cur_str
```

## 回溯

### 1. 分割回文串⭐️

[links](https://www.programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

- 如何模拟那些切割线？ 类似组合， startIndex代表切割线   
- 终止条件？切完整个字符串,即**startIndex==n**
- 在递归循环中如何截取子串？s[startIndex: i+1]代表下标startIndex~i  刚切出来
- 如何判断回文？ s==s[::-1]

```python
# 131.分割回文串: 分割成子串，每个子串都是回文串
result，path = [],[]  # 全局参数存结果
def backtracking(startIndex,s):
    # 终止条件
    if startIndex == len(s):
        result.append(path.copy()) # 必须复制  遍历到最后，说明整个字符串都被分为回文串。保存结果
        return
    for i in range(startIndex, len(s)): # i取值0~n-1
      	strr=s[startIndex:i+1]  # 刚切出来
        if strr == strr[::-1]: # 如果回文，才继续剩余部分的切分 
            path.append(strr)
            self.backtracking(s, i+1, path, result) # 纵向 从下一字符切割，判断其余是否仍为回文串
            path.pop() # 回溯
startIndex=0 # 切割线
backtracking(startIndex,s)
return result
```



## 动态规划

### 背包问题

#### 1. 分割等和子集（01背包、正好装满）

- dp定义：dp[i] 用nums数组的元素组合，使得恰好等于容量i   False装不成  True正好装满
- 递推公式  dp[i] 当背包容量大于物品j的容量nums[j]时  验证dp[i] or dp[i-nums[j]]
- 顺序:  先物品后背包  一维dp内层倒序

```python
# 边界条件
if sum(nums)%2!=0:
    return False
target=sum(nums)//2
dp=[False]* (target+1) # 0代表空背包  下标从1~n代表容量 全部初始化为False

dp[0]=True
for i in range(len(nums)): # 先物品  i下标0~n-1
    for j in range(target,0,-1): # 再背包  j下标n~1  01背包内层倒序
        # 如果背包容量大于物品，则才有变化
        if j >=nums[i]:
            dp[j]= dp[j] or dp[j-nums[i]]
return dp[target]
```

#### 2. 单词拆分（完全背包、正好装满、求排列）

[Links](https://www.programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html)  单词列表是否能拼出字符串（完全背包）

1. 定义  dp[i] 字符串前i个元素（下标从0~i-1）能否拼出， False拼不出 True能拼出。0表示空，下标1~n对应元素s[i-1] 

2. 递推公式  dp[i] 依赖于  0<=j<i  dp[j]=True 且s[j:i]出现在wordDict，则dp[i]=True

   dp[j] 代表s[0]~s[j-1],即s[0:j]
   dp[i]代表s[0]~s[i-1],即s[0:i]
   故dp[j] ->dp[i]中间的字符串是 s[j:i]

3. 初始化   dp[0]=True

4. 顺序    求排列，故顺序特殊  先背包后物品

```python
dp=[False] *(len(s)+1) # dp[i] 表示字符串的前 i 个字符是否可以被拆分成单词
dp[0]=True # 空字符True

for i in range(1,len(s)+1):  # 背包容量 1~n
    for j in range(i): # 物品j  0~i-1  
        #判断当前是否拼出
        if dp[j] and s[j:i] in wordDict: # 如果 s[0:j] 可以被拆分成单词，并且 s[j:i] 在单词集合中存在，则 s[0:i] 可以被拆分成单词
            dp[i]=True
            break
return dp[-1]
```



### 子序列问题

#### 1. 最短编辑距离⭐️

[links](https://www.programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)  两个单词 word1 和 word2，将 word1 转换成 word2 所使用的最少操作数 

1. dp定义： word1前i个字符 word2前j个字符的最小编辑距离

2. 递推公式

   - 如果当前两个元素相等，则不操作 `dp[i] [j] = dp[i-1] [j-1]`

   - 不相等，需要增删改  `min(dp[i-1][j]+1, dp[i][j-1]+1), dp[i-1][j-1]+1)`

     - 删除/增加：word1删除则`dp[i-1][j]+1`   或者  word2删除 `dp[i][j-1]+1)`

       word1删除一个字符   等价于 word2增加一个字符

     - 改：`dp[i-1][j-1]+1`

3. 顺序

   <img src="./assets/image-20241213下午33015685.png" alt="image-20241211下午115724714" style="zoom:50%;" />

   

   

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        # word1是行   word2是列  从空开始,下标1~n代表元素word[i-1]
        # dp[i][j]  word1前i个字符 word2前j个字符的最小编辑距离
        # 递推公式
            # 当前两个元素如果相等，则不操作 dp[i-1][j-1]
            # 不等，需要 插入==删除、 替换。取最小
            	# 删除  dp[i-1][j]+1   dp[i][j-1] +1  
            	# 替换  dp[i-1][j-1]+1 
        dp=[ [float("inf")] * (len(word2)+1)  for _ in range(len(word1)+1)]

        # 初始化
        for i in range(len(word1)+1): # 取值范围1~n
            dp[i][0]=i
        for j in range(len(word2)+1): # 取值范围1~n
            dp[0][j]=j
        
        for i in range(1,len(word1)+1):
            for j in range(1,len(word2)+1):
                # 当前元素是否相等
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    # 删除  插入等价
                    dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1
        return dp[-1][-1]
```

#### 2. 最长回文子串⭐️

[links](https://github.com/youngyangyang04/leetcode-master/blob/d3ae53e107a871c73b2d08094d586a9b711ee105/problems/0005.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.md)

动态规划

```python
# 动态规划
class Solution:
    def countSubstrings(self, s: str) -> int:
        dp = [[False] * len(s) for _ in range(len(s))]
        result = 0
        for i in range(len(s)-1, -1, -1): #注意遍历顺序
            for j in range(i, len(s)):
                if s[i] == s[j]:
                    if j - i <= 1: #情况一 和 情况二
                        result += 1
                        dp[i][j] = True
                    elif dp[i+1][j-1]: #情况三
                        result += 1
                        dp[i][j] = True
        return result
```

双指针

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        # 奇数串  偶数串
        def expand(left,right,s):
            # 合法区间内往外拓展 找最长子串
            while left>=0 and right<len(s) and s[left]==s[right]:
                left-=1
                right+=1
            return s[left+1:right] # while终止时回文子串区间left+1 ~ right-1 左开右闭
        
        long_str=""
        for i in range(len(s)):
            odd_str= expand(i,i,s)  # 以 s[i] 为中心的最长回文子串
            even_str=expand(i,i+1,s) # 以 s[i] 和 s[i+1] 为中心的最长回文子串
            long_str = max(long_str,odd_str,even_str,key=len)
        return long_str
```

#### 3. 最长公共子序列

[Links](https://www.programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html)  两个字符串的最长公共子序列的长度

<img src="./assets/image-20241211下午104930090.png" alt="image-20241211下午104930090" style="zoom:50%;" />

[Links](https://www.programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html)

1. dp定义：dp[i] [j]   text1前i个字符，text2前j个字符的最长公共子序列   
   - 0代表空字符串    i下标1~n，对应元素text[i-1]
   
2. 递推公式：
   - text1[i-1] 与 text2[j-1] 当前字符相同，则dp[i] [j] = dp[i - 1] [j - 1] + 1
   - text1[i-1] 与 text2[ j-1]当前字符不同，则dp[i] [j] = max(dp[i - 1] [j], dp[i] [j - 1])
   
3. 初始化：第一行 第一列都为空

4. 顺序

   <img src="./assets/image-20241211下午105348197.png" alt="image-20241211下午105348197" style="zoom:50%;" />

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        # 两个字符串都从空开始 故都加1    text1是行   text2是列
        dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)]
        
        for i in range(1, len(text1) + 1): # 1~m 对应元素text[i-1]
            for j in range(1, len(text2) + 1): # 1~n  对应元素text[j-1]
              	# 如果当前两个字符相等，则左上角位置+1
                if text1[i-1] == text2[j-1]: 
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        # 返回最长公共子序列的长度
        return dp[len(text1)][len(text2)]
```

#### 4. 最长连续递增序列

[links](https://www.programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html)  整数数组中找出最长严格递增子序列的长度

[Links](https://www.programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

1. dp定义: dp[i]表示**0~i-1范围**且**nums[i-1]结尾**的最长递增子序列的长度。 i取值0~n-1，对应元素nums[0]~nums[n-1]
2. 递推公式：dp[i]依赖  nums[i]>nums[j]时max(dp[i],dp[j]+1)    j取值0~i-1
3. 初始化：每一个i，dp[i]起始大小至少都是1

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return len(nums)
        dp = [1] * len(nums) # i取值0~n-1
        dp[0]=1 #初始化
        for i in range(1, len(nums)): # 从第二个开始看递增子序列  范围1~n-1
            for j in range(i): # j取值0~i-1
                if nums[i] > nums[j]: # 大于才有机会
                    dp[i] = max(dp[i], dp[j] + 1)    
        return max(dp)
```

## Todo

1. 柱状图中的最大矩形